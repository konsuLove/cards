<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Flip Card Deck â€” Click to Reveal</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <link href="styles.css" rel="stylesheet">
</head>

<body>
    <div class="app" role="application">
        <div class="left">
            <div class="hero">
                <div>
                    <h1>Conversation cards</h1>

                </div>
                <div style="text-align:right">
                    <div class="small">Deck: <strong id="remaining">10</strong> left</div>
                    <div class="small">Current: <strong id="currentDeck">Dating</strong></div>
                </div>
            </div>

            <div class="stage" id="stage" aria-live="polite" aria-atomic="true">
                <!-- cards will be injected here -->
                <div class="stack" id="stack"></div>
            </div>

            <div class="controls">
                <button class="btn" id="revealBtn">Reveal Card</button>
                <button class="btn secondary" id="resetBtn">Reset Deck</button>
            </div>

            <div class="meta">Choose a deck from the right panel to get started with different conversation topics.</div>
        </div>

        <aside class="right">
            <div class="panel">
                <label>Choose a Deck</label>
                <div class="deck-selection" id="deckSelection">
                    <!-- deck options will be injected here -->
                </div>
                <div class="footer">Select a deck to start revealing conversation cards. Each deck contains 10 unique cards.</div>
            </div>
        </aside>
    </div>

    <template id="miniTpl">
        <div class="mini"></div>
    </template>

    <script>
        // ==== DECK CONFIGURATION ====
        const decks = {
            dating: {
                name: "Dating",
                cards: [
                    "What's your ideal first date?",
                    "Share your most embarrassing moment",
                    "What's your love language?",
                    "Describe your perfect partner",
                    "What's your biggest relationship fear?",
                    "Share a childhood memory",
                    "What makes you laugh the most?",
                    "Describe your dream vacation",
                    "What's your biggest pet peeve?",
                    "Share something you're passionate about"
                ]
            },
            friends: {
                name: "Friends",
                cards: [
                    "What's your favorite childhood game?",
                    "Share your most random skill",
                    "What's your go-to comfort food?",
                    "Describe your perfect weekend",
                    "What's the weirdest dream you've had?",
                    "Share your favorite joke",
                    "What's your hidden talent?",
                    "Describe your ideal party",
                    "What's your biggest irrational fear?",
                    "Share your favorite memory with friends"
                ]
            },
            dilemmas: {
                name: "Dilemmas",
                cards: [
                    "Would you rather have super strength or super speed?",
                    "What's your biggest moral dilemma?",
                    "Would you rather be famous or wealthy?",
                    "What's the hardest decision you've made?",
                    "Would you rather live in the past or future?",
                    "What's your biggest ethical question?",
                    "Would you rather be invisible or fly?",
                    "What's your most controversial opinion?",
                    "Would you rather have perfect memory or forget everything?",
                    "What's your biggest philosophical question?"
                ]
            }
        };

        // state
        let currentDeckType = 'dating';
        let deck = [...decks[currentDeckType].cards];
        let remaining = [];

        const stage = document.getElementById('stage');
        const revealBtn = document.getElementById('revealBtn');
        const resetBtn = document.getElementById('resetBtn');
        const remainingEl = document.getElementById('remaining');
        const currentDeckEl = document.getElementById('currentDeck');
        const deckSelection = document.getElementById('deckSelection');
        const stack = document.getElementById('stack');

        function init() {
            renderDeckSelection();
            switchDeck('dating');
        }

        function switchDeck(deckType) {
            currentDeckType = deckType;
            deck = [...decks[deckType].cards];
            currentDeckEl.textContent = decks[deckType].name;
            resetDeck();
        }

        function resetDeck() {
            remaining = deck.map((t, i) => ({ text: t, index: i }));
            updateRemaining();
            stack.innerHTML = '';
            // remove any current card
            const existing = stage.querySelector('.card');
            if (existing) existing.remove();
        }

        function updateRemaining() {
            remainingEl.textContent = remaining.length;
        }

        function renderDeckSelection() {
            deckSelection.innerHTML = '';
            Object.keys(decks).forEach(deckType => {
                const deckOption = document.createElement('div');
                deckOption.className = `deck-option ${deckType === currentDeckType ? 'active' : ''}`;
                deckOption.innerHTML = `
                    <div class="deck-name">${decks[deckType].name}</div>
                    <div class="deck-description">${getDeckDescription(deckType)}</div>
                `;
                deckOption.addEventListener('click', () => {
                    switchDeck(deckType);
                    // Update active state
                    document.querySelectorAll('.deck-option').forEach(opt => opt.classList.remove('active'));
                    deckOption.classList.add('active');
                });
                deckSelection.appendChild(deckOption);
            });
        }

        function getDeckDescription(deckType) {
            const descriptions = {
                dating: "Conversation starters for romantic connections",
                friends: "Fun questions for hanging out with friends", 
                dilemmas: "Thought-provoking scenarios and choices"
            };
            return descriptions[deckType];
        }

        function pickRandomCard() {
            if (remaining.length === 0) return null;
            const r = Math.floor(Math.random() * remaining.length);
            const item = remaining.splice(r, 1)[0];
            updateRemaining();
            return item;
        }

        function showCard(item) {
            // remove previous card but keep a mini stack preview
            const prev = stage.querySelector('.card');
            if (prev) {
                // create mini preview
                const tpl = document.getElementById('miniTpl');
                const mini = tpl.content.firstElementChild.cloneNode(true);
                mini.textContent = prev.textContent;
                // Scale text for mini card
                scaleMiniTextToFit(mini);
                // stack up to 4 minis
                stack.insertBefore(mini, stack.firstChild);
                if (stack.children.length > 4) stack.removeChild(stack.lastChild);
                prev.remove();
            }

            const card = document.createElement('div');
            card.className = 'card enter';
            card.setAttribute('role', 'article');
            card.setAttribute('aria-label', 'Revealed card');
            card.textContent = item.text;
            stage.appendChild(card);

            // Scale text to fit the card
            scaleTextToFit(card);

            // small focus for keyboard users
            card.tabIndex = -1;
            setTimeout(() => card.focus(), 350);
        }

        function scaleTextToFit(card) {
            const text = card.textContent;
            const cardRect = card.getBoundingClientRect();
            const maxWidth = cardRect.width - 48; // Account for padding
            const maxHeight = cardRect.height - 48; // Account for padding
            
            // Start with a larger base font size
            let fontSize = 24;
            card.style.fontSize = fontSize + 'px';
            
            // Create a temporary element to measure text
            const temp = document.createElement('div');
            temp.style.position = 'absolute';
            temp.style.visibility = 'hidden';
            temp.style.whiteSpace = 'nowrap';
            temp.style.fontSize = fontSize + 'px';
            temp.style.fontWeight = '600';
            temp.style.fontFamily = 'Inter, system-ui, sans-serif';
            temp.textContent = text;
            document.body.appendChild(temp);
            
            // Scale down until text fits, with higher minimum size
            while ((temp.offsetWidth > maxWidth || temp.offsetHeight > maxHeight) && fontSize > 16) {
                fontSize -= 0.5;
                temp.style.fontSize = fontSize + 'px';
            }
            
            // Clean up
            document.body.removeChild(temp);
            
            // Apply the calculated font size
            card.style.fontSize = fontSize + 'px';
        }

        function scaleMiniTextToFit(mini) {
            const text = mini.textContent;
            const miniRect = mini.getBoundingClientRect();
            const maxWidth = miniRect.width - 16; // Account for padding
            const maxHeight = miniRect.height - 16; // Account for padding
            
            // Start with a larger base font size for mini cards
            let fontSize = 16;
            mini.style.fontSize = fontSize + 'px';
            
            // Create a temporary element to measure text
            const temp = document.createElement('div');
            temp.style.position = 'absolute';
            temp.style.visibility = 'hidden';
            temp.style.whiteSpace = 'nowrap';
            temp.style.fontSize = fontSize + 'px';
            temp.style.fontWeight = '700';
            temp.style.fontFamily = 'Inter, system-ui, sans-serif';
            temp.textContent = text;
            document.body.appendChild(temp);
            
            // Scale down until text fits, with higher minimum size
            while ((temp.offsetWidth > maxWidth || temp.offsetHeight > maxHeight) && fontSize > 10) {
                fontSize -= 0.5;
                temp.style.fontSize = fontSize + 'px';
            }
            
            // Clean up
            document.body.removeChild(temp);
            
            // Apply the calculated font size
            mini.style.fontSize = fontSize + 'px';
        }

        revealBtn.addEventListener('click', () => {
            const item = pickRandomCard();
            if (!item) {
                alert('Deck empty â€” click Reset Deck to shuffle and reveal again.');
                return;
            }
            showCard(item);
        });

        resetBtn.addEventListener('click', () => {
            resetDeck();
        });

        // allow Enter key on reveal button
        revealBtn.addEventListener('keydown', (e) => { if (e.key === 'Enter') revealBtn.click(); });

        // Handle window resize to rescale text
        window.addEventListener('resize', () => {
            const currentCard = stage.querySelector('.card');
            if (currentCard) {
                scaleTextToFit(currentCard);
            }
            
            // Rescale all mini cards
            const miniCards = stack.querySelectorAll('.mini');
            miniCards.forEach(mini => {
                scaleMiniTextToFit(mini);
            });
        });

        // initialize the app
        init();
    </script>
</body>

</html>